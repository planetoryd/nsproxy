//! # DBus interface proxies for: `org.freedesktop.systemd1.Service`, `org.freedesktop.systemd1.Unit`
//!
//! This code was generated by `zbus-xmlgen` `3.1.1` from DBus introspection data.
//! Source: `Interface '/org/freedesktop/systemd1/unit/shadow_2eservice' from service 'org.freedesktop.systemd1' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the
//! [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
//! section of the zbus documentation.
//!
//! This DBus object implements
//! [standard DBus interfaces](https://dbus.freedesktop.org/doc/dbus-specification.html),
//! (`org.freedesktop.DBus.*`) for which the following zbus proxies can be used:
//!
//! * [`zbus::fdo::PeerProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PropertiesProxy`]
//!
//! â€¦consequently `zbus-xmlgen` did not generate code for the above interfaces.

use zbus::dbus_proxy;

#[dbus_proxy(
    interface = "org.freedesktop.systemd1.Service",
    default_service = "org.freedesktop.systemd1",
    default_path = "/org/freedesktop/systemd1/unit/shadow_2eservice"
)]
trait Service {
    /// AttachProcesses method
    fn attach_processes(&self, subcgroup: &str, pids: &[u32]) -> zbus::Result<()>;

    /// BindMount method
    fn bind_mount(
        &self,
        source: &str,
        destination: &str,
        read_only: bool,
        mkdir: bool,
    ) -> zbus::Result<()>;

    /// DumpFileDescriptorStore method
    fn dump_file_descriptor_store(
        &self,
    ) -> zbus::Result<Vec<(String, u32, u32, u32, u64, u32, u32, String, u32)>>;

    /// GetProcesses method
    fn get_processes(&self) -> zbus::Result<Vec<(String, u32, String)>>;

    /// MountImage method
    fn mount_image(
        &self,
        source: &str,
        destination: &str,
        read_only: bool,
        mkdir: bool,
        options: &[(&str, &str)],
    ) -> zbus::Result<()>;

    /// AllowedCPUs property
    #[dbus_proxy(property, name = "AllowedCPUs")]
    fn allowed_cpus(&self) -> zbus::Result<Vec<u8>>;

    /// AllowedMemoryNodes property
    #[dbus_proxy(property)]
    fn allowed_memory_nodes(&self) -> zbus::Result<Vec<u8>>;

    /// AmbientCapabilities property
    #[dbus_proxy(property)]
    fn ambient_capabilities(&self) -> zbus::Result<u64>;

    /// AppArmorProfile property
    #[dbus_proxy(property)]
    fn app_armor_profile(&self) -> zbus::Result<(bool, String)>;

    /// BPFProgram property
    #[dbus_proxy(property, name = "BPFProgram")]
    fn bpfprogram(&self) -> zbus::Result<Vec<(String, String)>>;

    /// BindPaths property
    #[dbus_proxy(property)]
    fn bind_paths(&self) -> zbus::Result<Vec<(String, String, bool, u64)>>;

    /// BindReadOnlyPaths property
    #[dbus_proxy(property)]
    fn bind_read_only_paths(&self) -> zbus::Result<Vec<(String, String, bool, u64)>>;

    /// BlockIOAccounting property
    #[dbus_proxy(property, name = "BlockIOAccounting")]
    fn block_ioaccounting(&self) -> zbus::Result<bool>;

    /// BlockIODeviceWeight property
    #[dbus_proxy(property, name = "BlockIODeviceWeight")]
    fn block_iodevice_weight(&self) -> zbus::Result<Vec<(String, u64)>>;

    /// BlockIOReadBandwidth property
    #[dbus_proxy(property, name = "BlockIOReadBandwidth")]
    fn block_ioread_bandwidth(&self) -> zbus::Result<Vec<(String, u64)>>;

    /// BlockIOWeight property
    #[dbus_proxy(property, name = "BlockIOWeight")]
    fn block_ioweight(&self) -> zbus::Result<u64>;

    /// BlockIOWriteBandwidth property
    #[dbus_proxy(property, name = "BlockIOWriteBandwidth")]
    fn block_iowrite_bandwidth(&self) -> zbus::Result<Vec<(String, u64)>>;

    /// BusName property
    #[dbus_proxy(property)]
    fn bus_name(&self) -> zbus::Result<String>;

    /// CPUAccounting property
    #[dbus_proxy(property, name = "CPUAccounting")]
    fn cpuaccounting(&self) -> zbus::Result<bool>;

    /// CPUAffinity property
    #[dbus_proxy(property, name = "CPUAffinity")]
    fn cpuaffinity(&self) -> zbus::Result<Vec<u8>>;

    /// CPUAffinityFromNUMA property
    #[dbus_proxy(property, name = "CPUAffinityFromNUMA")]
    fn cpuaffinity_from_numa(&self) -> zbus::Result<bool>;

    /// CPUQuotaPerSecUSec property
    #[dbus_proxy(property, name = "CPUQuotaPerSecUSec")]
    fn cpuquota_per_sec_usec(&self) -> zbus::Result<u64>;

    /// CPUQuotaPeriodUSec property
    #[dbus_proxy(property, name = "CPUQuotaPeriodUSec")]
    fn cpuquota_period_usec(&self) -> zbus::Result<u64>;

    /// CPUSchedulingPolicy property
    #[dbus_proxy(property, name = "CPUSchedulingPolicy")]
    fn cpuscheduling_policy(&self) -> zbus::Result<i32>;

    /// CPUSchedulingPriority property
    #[dbus_proxy(property, name = "CPUSchedulingPriority")]
    fn cpuscheduling_priority(&self) -> zbus::Result<i32>;

    /// CPUSchedulingResetOnFork property
    #[dbus_proxy(property, name = "CPUSchedulingResetOnFork")]
    fn cpuscheduling_reset_on_fork(&self) -> zbus::Result<bool>;

    /// CPUShares property
    #[dbus_proxy(property, name = "CPUShares")]
    fn cpushares(&self) -> zbus::Result<u64>;

    /// CPUUsageNSec property
    #[dbus_proxy(property, name = "CPUUsageNSec")]
    fn cpuusage_nsec(&self) -> zbus::Result<u64>;

    /// CPUWeight property
    #[dbus_proxy(property, name = "CPUWeight")]
    fn cpuweight(&self) -> zbus::Result<u64>;

    /// CacheDirectory property
    #[dbus_proxy(property)]
    fn cache_directory(&self) -> zbus::Result<Vec<String>>;

    /// CacheDirectoryMode property
    #[dbus_proxy(property)]
    fn cache_directory_mode(&self) -> zbus::Result<u32>;

    /// CacheDirectorySymlink property
    #[dbus_proxy(property)]
    fn cache_directory_symlink(&self) -> zbus::Result<Vec<(String, String, u64)>>;

    /// CapabilityBoundingSet property
    #[dbus_proxy(property)]
    fn capability_bounding_set(&self) -> zbus::Result<u64>;

    /// CleanResult property
    #[dbus_proxy(property)]
    fn clean_result(&self) -> zbus::Result<String>;

    /// ConfigurationDirectory property
    #[dbus_proxy(property)]
    fn configuration_directory(&self) -> zbus::Result<Vec<String>>;

    /// ConfigurationDirectoryMode property
    #[dbus_proxy(property)]
    fn configuration_directory_mode(&self) -> zbus::Result<u32>;

    /// ControlGroup property
    #[dbus_proxy(property)]
    fn control_group(&self) -> zbus::Result<String>;

    /// ControlGroupId property
    #[dbus_proxy(property)]
    fn control_group_id(&self) -> zbus::Result<u64>;

    /// ControlPID property
    #[dbus_proxy(property, name = "ControlPID")]
    fn control_pid(&self) -> zbus::Result<u32>;

    /// CoredumpFilter property
    #[dbus_proxy(property)]
    fn coredump_filter(&self) -> zbus::Result<u64>;

    /// DefaultMemoryLow property
    #[dbus_proxy(property)]
    fn default_memory_low(&self) -> zbus::Result<u64>;

    /// DefaultMemoryMin property
    #[dbus_proxy(property)]
    fn default_memory_min(&self) -> zbus::Result<u64>;

    /// DefaultStartupMemoryLow property
    #[dbus_proxy(property)]
    fn default_startup_memory_low(&self) -> zbus::Result<u64>;

    /// Delegate property
    #[dbus_proxy(property)]
    fn delegate(&self) -> zbus::Result<bool>;

    /// DelegateControllers property
    #[dbus_proxy(property)]
    fn delegate_controllers(&self) -> zbus::Result<Vec<String>>;

    /// DelegateSubgroup property
    #[dbus_proxy(property)]
    fn delegate_subgroup(&self) -> zbus::Result<String>;

    /// DeviceAllow property
    #[dbus_proxy(property)]
    fn device_allow(&self) -> zbus::Result<Vec<(String, String)>>;

    /// DevicePolicy property
    #[dbus_proxy(property)]
    fn device_policy(&self) -> zbus::Result<String>;

    /// DisableControllers property
    #[dbus_proxy(property)]
    fn disable_controllers(&self) -> zbus::Result<Vec<String>>;

    /// DynamicUser property
    #[dbus_proxy(property)]
    fn dynamic_user(&self) -> zbus::Result<bool>;

    /// EffectiveCPUs property
    #[dbus_proxy(property, name = "EffectiveCPUs")]
    fn effective_cpus(&self) -> zbus::Result<Vec<u8>>;

    /// EffectiveMemoryNodes property
    #[dbus_proxy(property)]
    fn effective_memory_nodes(&self) -> zbus::Result<Vec<u8>>;

    /// Environment property
    #[dbus_proxy(property)]
    fn environment(&self) -> zbus::Result<Vec<String>>;

    /// EnvironmentFiles property
    #[dbus_proxy(property)]
    fn environment_files(&self) -> zbus::Result<Vec<(String, bool)>>;

    /// ExecCondition property
    #[dbus_proxy(property)]
    fn exec_condition(
        &self,
    ) -> zbus::Result<Vec<(String, Vec<String>, bool, u64, u64, u64, u64, u32, i32, i32)>>;

    /// ExecConditionEx property
    #[dbus_proxy(property)]
    fn exec_condition_ex(
        &self,
    ) -> zbus::Result<
        Vec<(
            String,
            Vec<String>,
            Vec<String>,
            u64,
            u64,
            u64,
            u64,
            u32,
            i32,
            i32,
        )>,
    >;

    /// ExecMainCode property
    #[dbus_proxy(property)]
    fn exec_main_code(&self) -> zbus::Result<i32>;

    /// ExecMainExitTimestamp property
    #[dbus_proxy(property)]
    fn exec_main_exit_timestamp(&self) -> zbus::Result<u64>;

    /// ExecMainExitTimestampMonotonic property
    #[dbus_proxy(property)]
    fn exec_main_exit_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// ExecMainPID property
    #[dbus_proxy(property, name = "ExecMainPID")]
    fn exec_main_pid(&self) -> zbus::Result<u32>;

    /// ExecMainStartTimestamp property
    #[dbus_proxy(property)]
    fn exec_main_start_timestamp(&self) -> zbus::Result<u64>;

    /// ExecMainStartTimestampMonotonic property
    #[dbus_proxy(property)]
    fn exec_main_start_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// ExecMainStatus property
    #[dbus_proxy(property)]
    fn exec_main_status(&self) -> zbus::Result<i32>;

    /// ExecPaths property
    #[dbus_proxy(property)]
    fn exec_paths(&self) -> zbus::Result<Vec<String>>;

    /// ExecReload property
    #[dbus_proxy(property)]
    fn exec_reload(
        &self,
    ) -> zbus::Result<Vec<(String, Vec<String>, bool, u64, u64, u64, u64, u32, i32, i32)>>;

    /// ExecReloadEx property
    #[dbus_proxy(property)]
    fn exec_reload_ex(
        &self,
    ) -> zbus::Result<
        Vec<(
            String,
            Vec<String>,
            Vec<String>,
            u64,
            u64,
            u64,
            u64,
            u32,
            i32,
            i32,
        )>,
    >;

    /// ExecSearchPath property
    #[dbus_proxy(property)]
    fn exec_search_path(&self) -> zbus::Result<Vec<String>>;

    /// ExecStart property
    #[dbus_proxy(property)]
    fn exec_start(
        &self,
    ) -> zbus::Result<Vec<(String, Vec<String>, bool, u64, u64, u64, u64, u32, i32, i32)>>;

    /// ExecStartEx property
    #[dbus_proxy(property)]
    fn exec_start_ex(
        &self,
    ) -> zbus::Result<
        Vec<(
            String,
            Vec<String>,
            Vec<String>,
            u64,
            u64,
            u64,
            u64,
            u32,
            i32,
            i32,
        )>,
    >;

    /// ExecStartPost property
    #[dbus_proxy(property)]
    fn exec_start_post(
        &self,
    ) -> zbus::Result<Vec<(String, Vec<String>, bool, u64, u64, u64, u64, u32, i32, i32)>>;

    /// ExecStartPostEx property
    #[dbus_proxy(property)]
    fn exec_start_post_ex(
        &self,
    ) -> zbus::Result<
        Vec<(
            String,
            Vec<String>,
            Vec<String>,
            u64,
            u64,
            u64,
            u64,
            u32,
            i32,
            i32,
        )>,
    >;

    /// ExecStartPre property
    #[dbus_proxy(property)]
    fn exec_start_pre(
        &self,
    ) -> zbus::Result<Vec<(String, Vec<String>, bool, u64, u64, u64, u64, u32, i32, i32)>>;

    /// ExecStartPreEx property
    #[dbus_proxy(property)]
    fn exec_start_pre_ex(
        &self,
    ) -> zbus::Result<
        Vec<(
            String,
            Vec<String>,
            Vec<String>,
            u64,
            u64,
            u64,
            u64,
            u32,
            i32,
            i32,
        )>,
    >;

    /// ExecStop property
    #[dbus_proxy(property)]
    fn exec_stop(
        &self,
    ) -> zbus::Result<Vec<(String, Vec<String>, bool, u64, u64, u64, u64, u32, i32, i32)>>;

    /// ExecStopEx property
    #[dbus_proxy(property)]
    fn exec_stop_ex(
        &self,
    ) -> zbus::Result<
        Vec<(
            String,
            Vec<String>,
            Vec<String>,
            u64,
            u64,
            u64,
            u64,
            u32,
            i32,
            i32,
        )>,
    >;

    /// ExecStopPost property
    #[dbus_proxy(property)]
    fn exec_stop_post(
        &self,
    ) -> zbus::Result<Vec<(String, Vec<String>, bool, u64, u64, u64, u64, u32, i32, i32)>>;

    /// ExecStopPostEx property
    #[dbus_proxy(property)]
    fn exec_stop_post_ex(
        &self,
    ) -> zbus::Result<
        Vec<(
            String,
            Vec<String>,
            Vec<String>,
            u64,
            u64,
            u64,
            u64,
            u32,
            i32,
            i32,
        )>,
    >;

    /// ExitType property
    #[dbus_proxy(property)]
    fn exit_type(&self) -> zbus::Result<String>;

    /// ExtensionDirectories property
    #[dbus_proxy(property)]
    fn extension_directories(&self) -> zbus::Result<Vec<String>>;

    /// ExtensionImagePolicy property
    #[dbus_proxy(property)]
    fn extension_image_policy(&self) -> zbus::Result<String>;

    /// ExtensionImages property
    #[dbus_proxy(property)]
    fn extension_images(&self) -> zbus::Result<Vec<(String, bool, Vec<(String, String)>)>>;

    /// FileDescriptorStoreMax property
    #[dbus_proxy(property)]
    fn file_descriptor_store_max(&self) -> zbus::Result<u32>;

    /// FileDescriptorStorePreserve property
    #[dbus_proxy(property)]
    fn file_descriptor_store_preserve(&self) -> zbus::Result<String>;

    /// FinalKillSignal property
    #[dbus_proxy(property)]
    fn final_kill_signal(&self) -> zbus::Result<i32>;

    /// GID property
    #[dbus_proxy(property, name = "GID")]
    fn gid(&self) -> zbus::Result<u32>;

    /// Group property
    #[dbus_proxy(property)]
    fn group(&self) -> zbus::Result<String>;

    /// GuessMainPID property
    #[dbus_proxy(property, name = "GuessMainPID")]
    fn guess_main_pid(&self) -> zbus::Result<bool>;

    /// IOAccounting property
    #[dbus_proxy(property, name = "IOAccounting")]
    fn ioaccounting(&self) -> zbus::Result<bool>;

    /// IODeviceLatencyTargetUSec property
    #[dbus_proxy(property, name = "IODeviceLatencyTargetUSec")]
    fn iodevice_latency_target_usec(&self) -> zbus::Result<Vec<(String, u64)>>;

    /// IODeviceWeight property
    #[dbus_proxy(property, name = "IODeviceWeight")]
    fn iodevice_weight(&self) -> zbus::Result<Vec<(String, u64)>>;

    /// IOReadBandwidthMax property
    #[dbus_proxy(property, name = "IOReadBandwidthMax")]
    fn ioread_bandwidth_max(&self) -> zbus::Result<Vec<(String, u64)>>;

    /// IOReadBytes property
    #[dbus_proxy(property, name = "IOReadBytes")]
    fn ioread_bytes(&self) -> zbus::Result<u64>;

    /// IOReadIOPSMax property
    #[dbus_proxy(property, name = "IOReadIOPSMax")]
    fn ioread_iopsmax(&self) -> zbus::Result<Vec<(String, u64)>>;

    /// IOReadOperations property
    #[dbus_proxy(property, name = "IOReadOperations")]
    fn ioread_operations(&self) -> zbus::Result<u64>;

    /// IOSchedulingClass property
    #[dbus_proxy(property, name = "IOSchedulingClass")]
    fn ioscheduling_class(&self) -> zbus::Result<i32>;

    /// IOSchedulingPriority property
    #[dbus_proxy(property, name = "IOSchedulingPriority")]
    fn ioscheduling_priority(&self) -> zbus::Result<i32>;

    /// IOWeight property
    #[dbus_proxy(property, name = "IOWeight")]
    fn ioweight(&self) -> zbus::Result<u64>;

    /// IOWriteBandwidthMax property
    #[dbus_proxy(property, name = "IOWriteBandwidthMax")]
    fn iowrite_bandwidth_max(&self) -> zbus::Result<Vec<(String, u64)>>;

    /// IOWriteBytes property
    #[dbus_proxy(property, name = "IOWriteBytes")]
    fn iowrite_bytes(&self) -> zbus::Result<u64>;

    /// IOWriteIOPSMax property
    #[dbus_proxy(property, name = "IOWriteIOPSMax")]
    fn iowrite_iopsmax(&self) -> zbus::Result<Vec<(String, u64)>>;

    /// IOWriteOperations property
    #[dbus_proxy(property, name = "IOWriteOperations")]
    fn iowrite_operations(&self) -> zbus::Result<u64>;

    /// IPAccounting property
    #[dbus_proxy(property, name = "IPAccounting")]
    fn ipaccounting(&self) -> zbus::Result<bool>;

    /// IPAddressAllow property
    #[dbus_proxy(property, name = "IPAddressAllow")]
    fn ipaddress_allow(&self) -> zbus::Result<Vec<(i32, Vec<u8>, u32)>>;

    /// IPAddressDeny property
    #[dbus_proxy(property, name = "IPAddressDeny")]
    fn ipaddress_deny(&self) -> zbus::Result<Vec<(i32, Vec<u8>, u32)>>;

    /// IPCNamespacePath property
    #[dbus_proxy(property, name = "IPCNamespacePath")]
    fn ipcnamespace_path(&self) -> zbus::Result<String>;

    /// IPEgressBytes property
    #[dbus_proxy(property, name = "IPEgressBytes")]
    fn ipegress_bytes(&self) -> zbus::Result<u64>;

    /// IPEgressFilterPath property
    #[dbus_proxy(property, name = "IPEgressFilterPath")]
    fn ipegress_filter_path(&self) -> zbus::Result<Vec<String>>;

    /// IPEgressPackets property
    #[dbus_proxy(property, name = "IPEgressPackets")]
    fn ipegress_packets(&self) -> zbus::Result<u64>;

    /// IPIngressBytes property
    #[dbus_proxy(property, name = "IPIngressBytes")]
    fn ipingress_bytes(&self) -> zbus::Result<u64>;

    /// IPIngressFilterPath property
    #[dbus_proxy(property, name = "IPIngressFilterPath")]
    fn ipingress_filter_path(&self) -> zbus::Result<Vec<String>>;

    /// IPIngressPackets property
    #[dbus_proxy(property, name = "IPIngressPackets")]
    fn ipingress_packets(&self) -> zbus::Result<u64>;

    /// IgnoreSIGPIPE property
    #[dbus_proxy(property, name = "IgnoreSIGPIPE")]
    fn ignore_sigpipe(&self) -> zbus::Result<bool>;

    /// ImportCredential property
    #[dbus_proxy(property)]
    fn import_credential(&self) -> zbus::Result<Vec<String>>;

    /// InaccessiblePaths property
    #[dbus_proxy(property)]
    fn inaccessible_paths(&self) -> zbus::Result<Vec<String>>;

    /// KeyringMode property
    #[dbus_proxy(property)]
    fn keyring_mode(&self) -> zbus::Result<String>;

    /// KillMode property
    #[dbus_proxy(property)]
    fn kill_mode(&self) -> zbus::Result<String>;

    /// KillSignal property
    #[dbus_proxy(property)]
    fn kill_signal(&self) -> zbus::Result<i32>;

    /// LimitAS property
    #[dbus_proxy(property, name = "LimitAS")]
    fn limit_as(&self) -> zbus::Result<u64>;

    /// LimitASSoft property
    #[dbus_proxy(property, name = "LimitASSoft")]
    fn limit_assoft(&self) -> zbus::Result<u64>;

    /// LimitCORE property
    #[dbus_proxy(property, name = "LimitCORE")]
    fn limit_core(&self) -> zbus::Result<u64>;

    /// LimitCORESoft property
    #[dbus_proxy(property, name = "LimitCORESoft")]
    fn limit_coresoft(&self) -> zbus::Result<u64>;

    /// LimitCPU property
    #[dbus_proxy(property, name = "LimitCPU")]
    fn limit_cpu(&self) -> zbus::Result<u64>;

    /// LimitCPUSoft property
    #[dbus_proxy(property, name = "LimitCPUSoft")]
    fn limit_cpusoft(&self) -> zbus::Result<u64>;

    /// LimitDATA property
    #[dbus_proxy(property, name = "LimitDATA")]
    fn limit_data(&self) -> zbus::Result<u64>;

    /// LimitDATASoft property
    #[dbus_proxy(property, name = "LimitDATASoft")]
    fn limit_datasoft(&self) -> zbus::Result<u64>;

    /// LimitFSIZE property
    #[dbus_proxy(property, name = "LimitFSIZE")]
    fn limit_fsize(&self) -> zbus::Result<u64>;

    /// LimitFSIZESoft property
    #[dbus_proxy(property, name = "LimitFSIZESoft")]
    fn limit_fsizesoft(&self) -> zbus::Result<u64>;

    /// LimitLOCKS property
    #[dbus_proxy(property, name = "LimitLOCKS")]
    fn limit_locks(&self) -> zbus::Result<u64>;

    /// LimitLOCKSSoft property
    #[dbus_proxy(property, name = "LimitLOCKSSoft")]
    fn limit_lockssoft(&self) -> zbus::Result<u64>;

    /// LimitMEMLOCK property
    #[dbus_proxy(property, name = "LimitMEMLOCK")]
    fn limit_memlock(&self) -> zbus::Result<u64>;

    /// LimitMEMLOCKSoft property
    #[dbus_proxy(property, name = "LimitMEMLOCKSoft")]
    fn limit_memlocksoft(&self) -> zbus::Result<u64>;

    /// LimitMSGQUEUE property
    #[dbus_proxy(property, name = "LimitMSGQUEUE")]
    fn limit_msgqueue(&self) -> zbus::Result<u64>;

    /// LimitMSGQUEUESoft property
    #[dbus_proxy(property, name = "LimitMSGQUEUESoft")]
    fn limit_msgqueuesoft(&self) -> zbus::Result<u64>;

    /// LimitNICE property
    #[dbus_proxy(property, name = "LimitNICE")]
    fn limit_nice(&self) -> zbus::Result<u64>;

    /// LimitNICESoft property
    #[dbus_proxy(property, name = "LimitNICESoft")]
    fn limit_nicesoft(&self) -> zbus::Result<u64>;

    /// LimitNOFILE property
    #[dbus_proxy(property, name = "LimitNOFILE")]
    fn limit_nofile(&self) -> zbus::Result<u64>;

    /// LimitNOFILESoft property
    #[dbus_proxy(property, name = "LimitNOFILESoft")]
    fn limit_nofilesoft(&self) -> zbus::Result<u64>;

    /// LimitNPROC property
    #[dbus_proxy(property, name = "LimitNPROC")]
    fn limit_nproc(&self) -> zbus::Result<u64>;

    /// LimitNPROCSoft property
    #[dbus_proxy(property, name = "LimitNPROCSoft")]
    fn limit_nprocsoft(&self) -> zbus::Result<u64>;

    /// LimitRSS property
    #[dbus_proxy(property, name = "LimitRSS")]
    fn limit_rss(&self) -> zbus::Result<u64>;

    /// LimitRSSSoft property
    #[dbus_proxy(property, name = "LimitRSSSoft")]
    fn limit_rsssoft(&self) -> zbus::Result<u64>;

    /// LimitRTPRIO property
    #[dbus_proxy(property, name = "LimitRTPRIO")]
    fn limit_rtprio(&self) -> zbus::Result<u64>;

    /// LimitRTPRIOSoft property
    #[dbus_proxy(property, name = "LimitRTPRIOSoft")]
    fn limit_rtpriosoft(&self) -> zbus::Result<u64>;

    /// LimitRTTIME property
    #[dbus_proxy(property, name = "LimitRTTIME")]
    fn limit_rttime(&self) -> zbus::Result<u64>;

    /// LimitRTTIMESoft property
    #[dbus_proxy(property, name = "LimitRTTIMESoft")]
    fn limit_rttimesoft(&self) -> zbus::Result<u64>;

    /// LimitSIGPENDING property
    #[dbus_proxy(property, name = "LimitSIGPENDING")]
    fn limit_sigpending(&self) -> zbus::Result<u64>;

    /// LimitSIGPENDINGSoft property
    #[dbus_proxy(property, name = "LimitSIGPENDINGSoft")]
    fn limit_sigpendingsoft(&self) -> zbus::Result<u64>;

    /// LimitSTACK property
    #[dbus_proxy(property, name = "LimitSTACK")]
    fn limit_stack(&self) -> zbus::Result<u64>;

    /// LimitSTACKSoft property
    #[dbus_proxy(property, name = "LimitSTACKSoft")]
    fn limit_stacksoft(&self) -> zbus::Result<u64>;

    /// LoadCredential property
    #[dbus_proxy(property)]
    fn load_credential(&self) -> zbus::Result<Vec<(String, String)>>;

    /// LoadCredentialEncrypted property
    #[dbus_proxy(property)]
    fn load_credential_encrypted(&self) -> zbus::Result<Vec<(String, String)>>;

    /// LockPersonality property
    #[dbus_proxy(property)]
    fn lock_personality(&self) -> zbus::Result<bool>;

    /// LogExtraFields property
    #[dbus_proxy(property)]
    fn log_extra_fields(&self) -> zbus::Result<Vec<Vec<u8>>>;

    /// LogFilterPatterns property
    #[dbus_proxy(property)]
    fn log_filter_patterns(&self) -> zbus::Result<Vec<(bool, String)>>;

    /// LogLevelMax property
    #[dbus_proxy(property)]
    fn log_level_max(&self) -> zbus::Result<i32>;

    /// LogNamespace property
    #[dbus_proxy(property)]
    fn log_namespace(&self) -> zbus::Result<String>;

    /// LogRateLimitBurst property
    #[dbus_proxy(property)]
    fn log_rate_limit_burst(&self) -> zbus::Result<u32>;

    /// LogRateLimitIntervalUSec property
    #[dbus_proxy(property, name = "LogRateLimitIntervalUSec")]
    fn log_rate_limit_interval_usec(&self) -> zbus::Result<u64>;

    /// LogsDirectory property
    #[dbus_proxy(property)]
    fn logs_directory(&self) -> zbus::Result<Vec<String>>;

    /// LogsDirectoryMode property
    #[dbus_proxy(property)]
    fn logs_directory_mode(&self) -> zbus::Result<u32>;

    /// LogsDirectorySymlink property
    #[dbus_proxy(property)]
    fn logs_directory_symlink(&self) -> zbus::Result<Vec<(String, String, u64)>>;

    /// MainPID property
    #[dbus_proxy(property, name = "MainPID")]
    fn main_pid(&self) -> zbus::Result<u32>;

    /// ManagedOOMMemoryPressure property
    #[dbus_proxy(property, name = "ManagedOOMMemoryPressure")]
    fn managed_oommemory_pressure(&self) -> zbus::Result<String>;

    /// ManagedOOMMemoryPressureLimit property
    #[dbus_proxy(property, name = "ManagedOOMMemoryPressureLimit")]
    fn managed_oommemory_pressure_limit(&self) -> zbus::Result<u32>;

    /// ManagedOOMPreference property
    #[dbus_proxy(property, name = "ManagedOOMPreference")]
    fn managed_oompreference(&self) -> zbus::Result<String>;

    /// ManagedOOMSwap property
    #[dbus_proxy(property, name = "ManagedOOMSwap")]
    fn managed_oomswap(&self) -> zbus::Result<String>;

    /// MemoryAccounting property
    #[dbus_proxy(property)]
    fn memory_accounting(&self) -> zbus::Result<bool>;

    /// MemoryAvailable property
    #[dbus_proxy(property)]
    fn memory_available(&self) -> zbus::Result<u64>;

    /// MemoryCurrent property
    #[dbus_proxy(property)]
    fn memory_current(&self) -> zbus::Result<u64>;

    /// MemoryDenyWriteExecute property
    #[dbus_proxy(property)]
    fn memory_deny_write_execute(&self) -> zbus::Result<bool>;

    /// MemoryHigh property
    #[dbus_proxy(property)]
    fn memory_high(&self) -> zbus::Result<u64>;

    /// MemoryKSM property
    #[dbus_proxy(property, name = "MemoryKSM")]
    fn memory_ksm(&self) -> zbus::Result<bool>;

    /// MemoryLimit property
    #[dbus_proxy(property)]
    fn memory_limit(&self) -> zbus::Result<u64>;

    /// MemoryLow property
    #[dbus_proxy(property)]
    fn memory_low(&self) -> zbus::Result<u64>;

    /// MemoryMax property
    #[dbus_proxy(property)]
    fn memory_max(&self) -> zbus::Result<u64>;

    /// MemoryMin property
    #[dbus_proxy(property)]
    fn memory_min(&self) -> zbus::Result<u64>;

    /// MemoryPressureThresholdUSec property
    #[dbus_proxy(property, name = "MemoryPressureThresholdUSec")]
    fn memory_pressure_threshold_usec(&self) -> zbus::Result<u64>;

    /// MemoryPressureWatch property
    #[dbus_proxy(property)]
    fn memory_pressure_watch(&self) -> zbus::Result<String>;

    /// MemorySwapMax property
    #[dbus_proxy(property)]
    fn memory_swap_max(&self) -> zbus::Result<u64>;

    /// MemoryZSwapMax property
    #[dbus_proxy(property, name = "MemoryZSwapMax")]
    fn memory_zswap_max(&self) -> zbus::Result<u64>;

    /// MountAPIVFS property
    #[dbus_proxy(property, name = "MountAPIVFS")]
    fn mount_apivfs(&self) -> zbus::Result<bool>;

    /// MountFlags property
    #[dbus_proxy(property)]
    fn mount_flags(&self) -> zbus::Result<u64>;

    /// MountImagePolicy property
    #[dbus_proxy(property)]
    fn mount_image_policy(&self) -> zbus::Result<String>;

    /// MountImages property
    #[dbus_proxy(property)]
    fn mount_images(&self) -> zbus::Result<Vec<(String, String, bool, Vec<(String, String)>)>>;

    /// NFileDescriptorStore property
    #[dbus_proxy(property, name = "NFileDescriptorStore")]
    fn nfile_descriptor_store(&self) -> zbus::Result<u32>;

    /// NRestarts property
    #[dbus_proxy(property, name = "NRestarts")]
    fn nrestarts(&self) -> zbus::Result<u32>;

    /// NUMAMask property
    #[dbus_proxy(property, name = "NUMAMask")]
    fn numamask(&self) -> zbus::Result<Vec<u8>>;

    /// NUMAPolicy property
    #[dbus_proxy(property, name = "NUMAPolicy")]
    fn numapolicy(&self) -> zbus::Result<i32>;

    /// NetworkNamespacePath property
    #[dbus_proxy(property)]
    fn network_namespace_path(&self) -> zbus::Result<String>;

    /// Nice property
    #[dbus_proxy(property)]
    fn nice(&self) -> zbus::Result<i32>;

    /// NoExecPaths property
    #[dbus_proxy(property)]
    fn no_exec_paths(&self) -> zbus::Result<Vec<String>>;

    /// NoNewPrivileges property
    #[dbus_proxy(property)]
    fn no_new_privileges(&self) -> zbus::Result<bool>;

    /// NonBlocking property
    #[dbus_proxy(property)]
    fn non_blocking(&self) -> zbus::Result<bool>;

    /// NotifyAccess property
    #[dbus_proxy(property)]
    fn notify_access(&self) -> zbus::Result<String>;

    /// OOMPolicy property
    #[dbus_proxy(property, name = "OOMPolicy")]
    fn oompolicy(&self) -> zbus::Result<String>;

    /// OOMScoreAdjust property
    #[dbus_proxy(property, name = "OOMScoreAdjust")]
    fn oomscore_adjust(&self) -> zbus::Result<i32>;

    /// OpenFile property
    #[dbus_proxy(property)]
    fn open_file(&self) -> zbus::Result<Vec<(String, String, u64)>>;

    /// PAMName property
    #[dbus_proxy(property, name = "PAMName")]
    fn pamname(&self) -> zbus::Result<String>;

    /// PIDFile property
    #[dbus_proxy(property, name = "PIDFile")]
    fn pidfile(&self) -> zbus::Result<String>;

    /// PassEnvironment property
    #[dbus_proxy(property)]
    fn pass_environment(&self) -> zbus::Result<Vec<String>>;

    /// Personality property
    #[dbus_proxy(property)]
    fn personality(&self) -> zbus::Result<String>;

    /// PrivateDevices property
    #[dbus_proxy(property)]
    fn private_devices(&self) -> zbus::Result<bool>;

    /// PrivateIPC property
    #[dbus_proxy(property, name = "PrivateIPC")]
    fn private_ipc(&self) -> zbus::Result<bool>;

    /// PrivateMounts property
    #[dbus_proxy(property)]
    fn private_mounts(&self) -> zbus::Result<bool>;

    /// PrivateNetwork property
    #[dbus_proxy(property)]
    fn private_network(&self) -> zbus::Result<bool>;

    /// PrivateTmp property
    #[dbus_proxy(property)]
    fn private_tmp(&self) -> zbus::Result<bool>;

    /// PrivateUsers property
    #[dbus_proxy(property)]
    fn private_users(&self) -> zbus::Result<bool>;

    /// ProcSubset property
    #[dbus_proxy(property)]
    fn proc_subset(&self) -> zbus::Result<String>;

    /// ProtectClock property
    #[dbus_proxy(property)]
    fn protect_clock(&self) -> zbus::Result<bool>;

    /// ProtectControlGroups property
    #[dbus_proxy(property)]
    fn protect_control_groups(&self) -> zbus::Result<bool>;

    /// ProtectHome property
    #[dbus_proxy(property)]
    fn protect_home(&self) -> zbus::Result<String>;

    /// ProtectHostname property
    #[dbus_proxy(property)]
    fn protect_hostname(&self) -> zbus::Result<bool>;

    /// ProtectKernelLogs property
    #[dbus_proxy(property)]
    fn protect_kernel_logs(&self) -> zbus::Result<bool>;

    /// ProtectKernelModules property
    #[dbus_proxy(property)]
    fn protect_kernel_modules(&self) -> zbus::Result<bool>;

    /// ProtectKernelTunables property
    #[dbus_proxy(property)]
    fn protect_kernel_tunables(&self) -> zbus::Result<bool>;

    /// ProtectProc property
    #[dbus_proxy(property)]
    fn protect_proc(&self) -> zbus::Result<String>;

    /// ProtectSystem property
    #[dbus_proxy(property)]
    fn protect_system(&self) -> zbus::Result<String>;

    /// ReadOnlyPaths property
    #[dbus_proxy(property)]
    fn read_only_paths(&self) -> zbus::Result<Vec<String>>;

    /// ReadWritePaths property
    #[dbus_proxy(property)]
    fn read_write_paths(&self) -> zbus::Result<Vec<String>>;

    /// ReloadResult property
    #[dbus_proxy(property)]
    fn reload_result(&self) -> zbus::Result<String>;

    /// ReloadSignal property
    #[dbus_proxy(property)]
    fn reload_signal(&self) -> zbus::Result<i32>;

    /// RemainAfterExit property
    #[dbus_proxy(property)]
    fn remain_after_exit(&self) -> zbus::Result<bool>;

    /// RemoveIPC property
    #[dbus_proxy(property, name = "RemoveIPC")]
    fn remove_ipc(&self) -> zbus::Result<bool>;

    /// Restart property
    #[dbus_proxy(property)]
    fn restart(&self) -> zbus::Result<String>;

    /// RestartForceExitStatus property
    #[dbus_proxy(property)]
    fn restart_force_exit_status(&self) -> zbus::Result<(Vec<i32>, Vec<i32>)>;

    /// RestartKillSignal property
    #[dbus_proxy(property)]
    fn restart_kill_signal(&self) -> zbus::Result<i32>;

    /// RestartMaxDelayUSec property
    #[dbus_proxy(property, name = "RestartMaxDelayUSec")]
    fn restart_max_delay_usec(&self) -> zbus::Result<u64>;

    /// RestartMode property
    #[dbus_proxy(property)]
    fn restart_mode(&self) -> zbus::Result<String>;

    /// RestartPreventExitStatus property
    #[dbus_proxy(property)]
    fn restart_prevent_exit_status(&self) -> zbus::Result<(Vec<i32>, Vec<i32>)>;

    /// RestartSteps property
    #[dbus_proxy(property)]
    fn restart_steps(&self) -> zbus::Result<u32>;

    /// RestartUSec property
    #[dbus_proxy(property, name = "RestartUSec")]
    fn restart_usec(&self) -> zbus::Result<u64>;

    /// RestartUSecNext property
    #[dbus_proxy(property, name = "RestartUSecNext")]
    fn restart_usec_next(&self) -> zbus::Result<u64>;

    /// RestrictAddressFamilies property
    #[dbus_proxy(property)]
    fn restrict_address_families(&self) -> zbus::Result<(bool, Vec<String>)>;

    /// RestrictFileSystems property
    #[dbus_proxy(property)]
    fn restrict_file_systems(&self) -> zbus::Result<(bool, Vec<String>)>;

    /// RestrictNamespaces property
    #[dbus_proxy(property)]
    fn restrict_namespaces(&self) -> zbus::Result<u64>;

    /// RestrictNetworkInterfaces property
    #[dbus_proxy(property)]
    fn restrict_network_interfaces(&self) -> zbus::Result<(bool, Vec<String>)>;

    /// RestrictRealtime property
    #[dbus_proxy(property)]
    fn restrict_realtime(&self) -> zbus::Result<bool>;

    /// RestrictSUIDSGID property
    #[dbus_proxy(property, name = "RestrictSUIDSGID")]
    fn restrict_suidsgid(&self) -> zbus::Result<bool>;

    /// Result property
    #[dbus_proxy(property)]
    fn result(&self) -> zbus::Result<String>;

    /// RootDirectory property
    #[dbus_proxy(property)]
    fn root_directory(&self) -> zbus::Result<String>;

    /// RootDirectoryStartOnly property
    #[dbus_proxy(property)]
    fn root_directory_start_only(&self) -> zbus::Result<bool>;

    /// RootEphemeral property
    #[dbus_proxy(property)]
    fn root_ephemeral(&self) -> zbus::Result<bool>;

    /// RootHash property
    #[dbus_proxy(property)]
    fn root_hash(&self) -> zbus::Result<Vec<u8>>;

    /// RootHashPath property
    #[dbus_proxy(property)]
    fn root_hash_path(&self) -> zbus::Result<String>;

    /// RootHashSignature property
    #[dbus_proxy(property)]
    fn root_hash_signature(&self) -> zbus::Result<Vec<u8>>;

    /// RootHashSignaturePath property
    #[dbus_proxy(property)]
    fn root_hash_signature_path(&self) -> zbus::Result<String>;

    /// RootImage property
    #[dbus_proxy(property)]
    fn root_image(&self) -> zbus::Result<String>;

    /// RootImageOptions property
    #[dbus_proxy(property)]
    fn root_image_options(&self) -> zbus::Result<Vec<(String, String)>>;

    /// RootImagePolicy property
    #[dbus_proxy(property)]
    fn root_image_policy(&self) -> zbus::Result<String>;

    /// RootVerity property
    #[dbus_proxy(property)]
    fn root_verity(&self) -> zbus::Result<String>;

    /// RuntimeDirectory property
    #[dbus_proxy(property)]
    fn runtime_directory(&self) -> zbus::Result<Vec<String>>;

    /// RuntimeDirectoryMode property
    #[dbus_proxy(property)]
    fn runtime_directory_mode(&self) -> zbus::Result<u32>;

    /// RuntimeDirectoryPreserve property
    #[dbus_proxy(property)]
    fn runtime_directory_preserve(&self) -> zbus::Result<String>;

    /// RuntimeDirectorySymlink property
    #[dbus_proxy(property)]
    fn runtime_directory_symlink(&self) -> zbus::Result<Vec<(String, String, u64)>>;

    /// RuntimeMaxUSec property
    #[dbus_proxy(property, name = "RuntimeMaxUSec")]
    fn runtime_max_usec(&self) -> zbus::Result<u64>;

    /// RuntimeRandomizedExtraUSec property
    #[dbus_proxy(property, name = "RuntimeRandomizedExtraUSec")]
    fn runtime_randomized_extra_usec(&self) -> zbus::Result<u64>;

    /// SELinuxContext property
    #[dbus_proxy(property, name = "SELinuxContext")]
    fn selinux_context(&self) -> zbus::Result<(bool, String)>;

    /// SameProcessGroup property
    #[dbus_proxy(property)]
    fn same_process_group(&self) -> zbus::Result<bool>;

    /// SecureBits property
    #[dbus_proxy(property)]
    fn secure_bits(&self) -> zbus::Result<i32>;

    /// SendSIGHUP property
    #[dbus_proxy(property, name = "SendSIGHUP")]
    fn send_sighup(&self) -> zbus::Result<bool>;

    /// SendSIGKILL property
    #[dbus_proxy(property, name = "SendSIGKILL")]
    fn send_sigkill(&self) -> zbus::Result<bool>;

    /// SetCredential property
    #[dbus_proxy(property)]
    fn set_credential(&self) -> zbus::Result<Vec<(String, Vec<u8>)>>;

    /// SetCredentialEncrypted property
    #[dbus_proxy(property)]
    fn set_credential_encrypted(&self) -> zbus::Result<Vec<(String, Vec<u8>)>>;

    /// Slice property
    #[dbus_proxy(property)]
    fn slice(&self) -> zbus::Result<String>;

    /// SmackProcessLabel property
    #[dbus_proxy(property)]
    fn smack_process_label(&self) -> zbus::Result<(bool, String)>;

    /// SocketBindAllow property
    #[dbus_proxy(property)]
    fn socket_bind_allow(&self) -> zbus::Result<Vec<(i32, i32, u16, u16)>>;

    /// SocketBindDeny property
    #[dbus_proxy(property)]
    fn socket_bind_deny(&self) -> zbus::Result<Vec<(i32, i32, u16, u16)>>;

    /// StandardError property
    #[dbus_proxy(property)]
    fn standard_error(&self) -> zbus::Result<String>;

    /// StandardErrorFileDescriptorName property
    #[dbus_proxy(property)]
    fn standard_error_file_descriptor_name(&self) -> zbus::Result<String>;

    /// StandardInput property
    #[dbus_proxy(property)]
    fn standard_input(&self) -> zbus::Result<String>;

    /// StandardInputData property
    #[dbus_proxy(property)]
    fn standard_input_data(&self) -> zbus::Result<Vec<u8>>;

    /// StandardInputFileDescriptorName property
    #[dbus_proxy(property)]
    fn standard_input_file_descriptor_name(&self) -> zbus::Result<String>;

    /// StandardOutput property
    #[dbus_proxy(property)]
    fn standard_output(&self) -> zbus::Result<String>;

    /// StandardOutputFileDescriptorName property
    #[dbus_proxy(property)]
    fn standard_output_file_descriptor_name(&self) -> zbus::Result<String>;

    /// StartupAllowedCPUs property
    #[dbus_proxy(property, name = "StartupAllowedCPUs")]
    fn startup_allowed_cpus(&self) -> zbus::Result<Vec<u8>>;

    /// StartupAllowedMemoryNodes property
    #[dbus_proxy(property)]
    fn startup_allowed_memory_nodes(&self) -> zbus::Result<Vec<u8>>;

    /// StartupBlockIOWeight property
    #[dbus_proxy(property, name = "StartupBlockIOWeight")]
    fn startup_block_ioweight(&self) -> zbus::Result<u64>;

    /// StartupCPUShares property
    #[dbus_proxy(property, name = "StartupCPUShares")]
    fn startup_cpushares(&self) -> zbus::Result<u64>;

    /// StartupCPUWeight property
    #[dbus_proxy(property, name = "StartupCPUWeight")]
    fn startup_cpuweight(&self) -> zbus::Result<u64>;

    /// StartupIOWeight property
    #[dbus_proxy(property, name = "StartupIOWeight")]
    fn startup_ioweight(&self) -> zbus::Result<u64>;

    /// StartupMemoryHigh property
    #[dbus_proxy(property)]
    fn startup_memory_high(&self) -> zbus::Result<u64>;

    /// StartupMemoryLow property
    #[dbus_proxy(property)]
    fn startup_memory_low(&self) -> zbus::Result<u64>;

    /// StartupMemoryMax property
    #[dbus_proxy(property)]
    fn startup_memory_max(&self) -> zbus::Result<u64>;

    /// StartupMemorySwapMax property
    #[dbus_proxy(property)]
    fn startup_memory_swap_max(&self) -> zbus::Result<u64>;

    /// StartupMemoryZSwapMax property
    #[dbus_proxy(property, name = "StartupMemoryZSwapMax")]
    fn startup_memory_zswap_max(&self) -> zbus::Result<u64>;

    /// StateDirectory property
    #[dbus_proxy(property)]
    fn state_directory(&self) -> zbus::Result<Vec<String>>;

    /// StateDirectoryMode property
    #[dbus_proxy(property)]
    fn state_directory_mode(&self) -> zbus::Result<u32>;

    /// StateDirectorySymlink property
    #[dbus_proxy(property)]
    fn state_directory_symlink(&self) -> zbus::Result<Vec<(String, String, u64)>>;

    /// StatusErrno property
    #[dbus_proxy(property)]
    fn status_errno(&self) -> zbus::Result<i32>;

    /// StatusText property
    #[dbus_proxy(property)]
    fn status_text(&self) -> zbus::Result<String>;

    /// SuccessExitStatus property
    #[dbus_proxy(property)]
    fn success_exit_status(&self) -> zbus::Result<(Vec<i32>, Vec<i32>)>;

    /// SupplementaryGroups property
    #[dbus_proxy(property)]
    fn supplementary_groups(&self) -> zbus::Result<Vec<String>>;

    /// SyslogFacility property
    #[dbus_proxy(property)]
    fn syslog_facility(&self) -> zbus::Result<i32>;

    /// SyslogIdentifier property
    #[dbus_proxy(property)]
    fn syslog_identifier(&self) -> zbus::Result<String>;

    /// SyslogLevel property
    #[dbus_proxy(property)]
    fn syslog_level(&self) -> zbus::Result<i32>;

    /// SyslogLevelPrefix property
    #[dbus_proxy(property)]
    fn syslog_level_prefix(&self) -> zbus::Result<bool>;

    /// SyslogPriority property
    #[dbus_proxy(property)]
    fn syslog_priority(&self) -> zbus::Result<i32>;

    /// SystemCallArchitectures property
    #[dbus_proxy(property)]
    fn system_call_architectures(&self) -> zbus::Result<Vec<String>>;

    /// SystemCallErrorNumber property
    #[dbus_proxy(property)]
    fn system_call_error_number(&self) -> zbus::Result<i32>;

    /// SystemCallFilter property
    #[dbus_proxy(property)]
    fn system_call_filter(&self) -> zbus::Result<(bool, Vec<String>)>;

    /// SystemCallLog property
    #[dbus_proxy(property)]
    fn system_call_log(&self) -> zbus::Result<(bool, Vec<String>)>;

    /// TTYColumns property
    #[dbus_proxy(property, name = "TTYColumns")]
    fn ttycolumns(&self) -> zbus::Result<u16>;

    /// TTYPath property
    #[dbus_proxy(property, name = "TTYPath")]
    fn ttypath(&self) -> zbus::Result<String>;

    /// TTYReset property
    #[dbus_proxy(property, name = "TTYReset")]
    fn ttyreset(&self) -> zbus::Result<bool>;

    /// TTYRows property
    #[dbus_proxy(property, name = "TTYRows")]
    fn ttyrows(&self) -> zbus::Result<u16>;

    /// TTYVHangup property
    #[dbus_proxy(property, name = "TTYVHangup")]
    fn ttyvhangup(&self) -> zbus::Result<bool>;

    /// TTYVTDisallocate property
    #[dbus_proxy(property, name = "TTYVTDisallocate")]
    fn ttyvtdisallocate(&self) -> zbus::Result<bool>;

    /// TasksAccounting property
    #[dbus_proxy(property)]
    fn tasks_accounting(&self) -> zbus::Result<bool>;

    /// TasksCurrent property
    #[dbus_proxy(property)]
    fn tasks_current(&self) -> zbus::Result<u64>;

    /// TasksMax property
    #[dbus_proxy(property)]
    fn tasks_max(&self) -> zbus::Result<u64>;

    /// TemporaryFileSystem property
    #[dbus_proxy(property)]
    fn temporary_file_system(&self) -> zbus::Result<Vec<(String, String)>>;

    /// TimeoutAbortUSec property
    #[dbus_proxy(property, name = "TimeoutAbortUSec")]
    fn timeout_abort_usec(&self) -> zbus::Result<u64>;

    /// TimeoutCleanUSec property
    #[dbus_proxy(property, name = "TimeoutCleanUSec")]
    fn timeout_clean_usec(&self) -> zbus::Result<u64>;

    /// TimeoutStartFailureMode property
    #[dbus_proxy(property)]
    fn timeout_start_failure_mode(&self) -> zbus::Result<String>;

    /// TimeoutStartUSec property
    #[dbus_proxy(property, name = "TimeoutStartUSec")]
    fn timeout_start_usec(&self) -> zbus::Result<u64>;

    /// TimeoutStopFailureMode property
    #[dbus_proxy(property)]
    fn timeout_stop_failure_mode(&self) -> zbus::Result<String>;

    /// TimeoutStopUSec property
    #[dbus_proxy(property, name = "TimeoutStopUSec")]
    fn timeout_stop_usec(&self) -> zbus::Result<u64>;

    /// TimerSlackNSec property
    #[dbus_proxy(property, name = "TimerSlackNSec")]
    fn timer_slack_nsec(&self) -> zbus::Result<u64>;

    /// Type property
    #[dbus_proxy(property)]
    fn type_(&self) -> zbus::Result<String>;

    /// UID property
    #[dbus_proxy(property, name = "UID")]
    fn uid(&self) -> zbus::Result<u32>;

    /// UMask property
    #[dbus_proxy(property, name = "UMask")]
    fn umask(&self) -> zbus::Result<u32>;

    /// USBFunctionDescriptors property
    #[dbus_proxy(property, name = "USBFunctionDescriptors")]
    fn usbfunction_descriptors(&self) -> zbus::Result<String>;

    /// USBFunctionStrings property
    #[dbus_proxy(property, name = "USBFunctionStrings")]
    fn usbfunction_strings(&self) -> zbus::Result<String>;

    /// UnsetEnvironment property
    #[dbus_proxy(property)]
    fn unset_environment(&self) -> zbus::Result<Vec<String>>;

    /// User property
    #[dbus_proxy(property)]
    fn user(&self) -> zbus::Result<String>;

    /// UtmpIdentifier property
    #[dbus_proxy(property)]
    fn utmp_identifier(&self) -> zbus::Result<String>;

    /// UtmpMode property
    #[dbus_proxy(property)]
    fn utmp_mode(&self) -> zbus::Result<String>;

    /// WatchdogSignal property
    #[dbus_proxy(property)]
    fn watchdog_signal(&self) -> zbus::Result<i32>;

    /// WatchdogTimestamp property
    #[dbus_proxy(property)]
    fn watchdog_timestamp(&self) -> zbus::Result<u64>;

    /// WatchdogTimestampMonotonic property
    #[dbus_proxy(property)]
    fn watchdog_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// WatchdogUSec property
    #[dbus_proxy(property, name = "WatchdogUSec")]
    fn watchdog_usec(&self) -> zbus::Result<u64>;

    /// WorkingDirectory property
    #[dbus_proxy(property)]
    fn working_directory(&self) -> zbus::Result<String>;
}

#[dbus_proxy(
    interface = "org.freedesktop.systemd1.Unit",
    default_service = "org.freedesktop.systemd1",
    default_path = "/org/freedesktop/systemd1/unit/shadow_2eservice"
)]
trait Unit {
    /// Clean method
    fn clean(&self, mask: &[&str]) -> zbus::Result<()>;

    /// EnqueueJob method
    fn enqueue_job(
        &self,
        job_type: &str,
        job_mode: &str,
    ) -> zbus::Result<(
        u32,
        zbus::zvariant::OwnedObjectPath,
        String,
        zbus::zvariant::OwnedObjectPath,
        String,
        Vec<(
            u32,
            zbus::zvariant::OwnedObjectPath,
            String,
            zbus::zvariant::OwnedObjectPath,
            String,
        )>,
    )>;

    /// Freeze method
    fn freeze(&self) -> zbus::Result<()>;

    /// Kill method
    fn kill(&self, whom: &str, signal: i32) -> zbus::Result<()>;

    /// QueueSignal method
    fn queue_signal(&self, whom: &str, signal: i32, value: i32) -> zbus::Result<()>;

    /// Ref method
    fn ref_(&self) -> zbus::Result<()>;

    /// Reload method
    fn reload(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// ReloadOrRestart method
    fn reload_or_restart(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// ReloadOrTryRestart method
    fn reload_or_try_restart(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// ResetFailed method
    fn reset_failed(&self) -> zbus::Result<()>;

    /// Restart method
    fn restart(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// SetProperties method
    fn set_properties(
        &self,
        runtime: bool,
        properties: &[(&str, zbus::zvariant::Value<'_>)],
    ) -> zbus::Result<()>;

    /// Start method
    fn start(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// Stop method
    fn stop(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// Thaw method
    fn thaw(&self) -> zbus::Result<()>;

    /// TryRestart method
    fn try_restart(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// Unref method
    fn unref(&self) -> zbus::Result<()>;

    /// AccessSELinuxContext property
    #[dbus_proxy(property, name = "AccessSELinuxContext")]
    fn access_selinux_context(&self) -> zbus::Result<String>;

    /// ActivationDetails property
    #[dbus_proxy(property)]
    fn activation_details(&self) -> zbus::Result<Vec<(String, String)>>;

    /// ActiveEnterTimestamp property
    #[dbus_proxy(property)]
    fn active_enter_timestamp(&self) -> zbus::Result<u64>;

    /// ActiveEnterTimestampMonotonic property
    #[dbus_proxy(property)]
    fn active_enter_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// ActiveExitTimestamp property
    #[dbus_proxy(property)]
    fn active_exit_timestamp(&self) -> zbus::Result<u64>;

    /// ActiveExitTimestampMonotonic property
    #[dbus_proxy(property)]
    fn active_exit_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// ActiveState property
    #[dbus_proxy(property)]
    fn active_state(&self) -> zbus::Result<String>;

    /// After property
    #[dbus_proxy(property)]
    fn after(&self) -> zbus::Result<Vec<String>>;

    /// AllowIsolate property
    #[dbus_proxy(property)]
    fn allow_isolate(&self) -> zbus::Result<bool>;

    /// AssertResult property
    #[dbus_proxy(property)]
    fn assert_result(&self) -> zbus::Result<bool>;

    /// AssertTimestamp property
    #[dbus_proxy(property)]
    fn assert_timestamp(&self) -> zbus::Result<u64>;

    /// AssertTimestampMonotonic property
    #[dbus_proxy(property)]
    fn assert_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// Asserts property
    #[dbus_proxy(property)]
    fn asserts(&self) -> zbus::Result<Vec<(String, bool, bool, String, i32)>>;

    /// Before property
    #[dbus_proxy(property)]
    fn before(&self) -> zbus::Result<Vec<String>>;

    /// BindsTo property
    #[dbus_proxy(property)]
    fn binds_to(&self) -> zbus::Result<Vec<String>>;

    /// BoundBy property
    #[dbus_proxy(property)]
    fn bound_by(&self) -> zbus::Result<Vec<String>>;

    /// CanClean property
    #[dbus_proxy(property)]
    fn can_clean(&self) -> zbus::Result<Vec<String>>;

    /// CanFreeze property
    #[dbus_proxy(property)]
    fn can_freeze(&self) -> zbus::Result<bool>;

    /// CanIsolate property
    #[dbus_proxy(property)]
    fn can_isolate(&self) -> zbus::Result<bool>;

    /// CanReload property
    #[dbus_proxy(property)]
    fn can_reload(&self) -> zbus::Result<bool>;

    /// CanStart property
    #[dbus_proxy(property)]
    fn can_start(&self) -> zbus::Result<bool>;

    /// CanStop property
    #[dbus_proxy(property)]
    fn can_stop(&self) -> zbus::Result<bool>;

    /// CollectMode property
    #[dbus_proxy(property)]
    fn collect_mode(&self) -> zbus::Result<String>;

    /// ConditionResult property
    #[dbus_proxy(property)]
    fn condition_result(&self) -> zbus::Result<bool>;

    /// ConditionTimestamp property
    #[dbus_proxy(property)]
    fn condition_timestamp(&self) -> zbus::Result<u64>;

    /// ConditionTimestampMonotonic property
    #[dbus_proxy(property)]
    fn condition_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// Conditions property
    #[dbus_proxy(property)]
    fn conditions(&self) -> zbus::Result<Vec<(String, bool, bool, String, i32)>>;

    /// ConflictedBy property
    #[dbus_proxy(property)]
    fn conflicted_by(&self) -> zbus::Result<Vec<String>>;

    /// Conflicts property
    #[dbus_proxy(property)]
    fn conflicts(&self) -> zbus::Result<Vec<String>>;

    /// ConsistsOf property
    #[dbus_proxy(property)]
    fn consists_of(&self) -> zbus::Result<Vec<String>>;

    /// DefaultDependencies property
    #[dbus_proxy(property)]
    fn default_dependencies(&self) -> zbus::Result<bool>;

    /// Description property
    #[dbus_proxy(property)]
    fn description(&self) -> zbus::Result<String>;

    /// Documentation property
    #[dbus_proxy(property)]
    fn documentation(&self) -> zbus::Result<Vec<String>>;

    /// DropInPaths property
    #[dbus_proxy(property)]
    fn drop_in_paths(&self) -> zbus::Result<Vec<String>>;

    /// FailureAction property
    #[dbus_proxy(property)]
    fn failure_action(&self) -> zbus::Result<String>;

    /// FailureActionExitStatus property
    #[dbus_proxy(property)]
    fn failure_action_exit_status(&self) -> zbus::Result<i32>;

    /// Following property
    #[dbus_proxy(property)]
    fn following(&self) -> zbus::Result<String>;

    /// FragmentPath property
    #[dbus_proxy(property)]
    fn fragment_path(&self) -> zbus::Result<String>;

    /// FreezerState property
    #[dbus_proxy(property)]
    fn freezer_state(&self) -> zbus::Result<String>;

    /// Id property
    #[dbus_proxy(property)]
    fn id(&self) -> zbus::Result<String>;

    /// IgnoreOnIsolate property
    #[dbus_proxy(property)]
    fn ignore_on_isolate(&self) -> zbus::Result<bool>;

    /// InactiveEnterTimestamp property
    #[dbus_proxy(property)]
    fn inactive_enter_timestamp(&self) -> zbus::Result<u64>;

    /// InactiveEnterTimestampMonotonic property
    #[dbus_proxy(property)]
    fn inactive_enter_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// InactiveExitTimestamp property
    #[dbus_proxy(property)]
    fn inactive_exit_timestamp(&self) -> zbus::Result<u64>;

    /// InactiveExitTimestampMonotonic property
    #[dbus_proxy(property)]
    fn inactive_exit_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// InvocationID property
    #[dbus_proxy(property, name = "InvocationID")]
    fn invocation_id(&self) -> zbus::Result<Vec<u8>>;

    /// Job property
    #[dbus_proxy(property)]
    fn job(&self) -> zbus::Result<(u32, zbus::zvariant::OwnedObjectPath)>;

    /// JobRunningTimeoutUSec property
    #[dbus_proxy(property, name = "JobRunningTimeoutUSec")]
    fn job_running_timeout_usec(&self) -> zbus::Result<u64>;

    /// JobTimeoutAction property
    #[dbus_proxy(property)]
    fn job_timeout_action(&self) -> zbus::Result<String>;

    /// JobTimeoutRebootArgument property
    #[dbus_proxy(property)]
    fn job_timeout_reboot_argument(&self) -> zbus::Result<String>;

    /// JobTimeoutUSec property
    #[dbus_proxy(property, name = "JobTimeoutUSec")]
    fn job_timeout_usec(&self) -> zbus::Result<u64>;

    /// JoinsNamespaceOf property
    #[dbus_proxy(property)]
    fn joins_namespace_of(&self) -> zbus::Result<Vec<String>>;

    /// LoadError property
    #[dbus_proxy(property)]
    fn load_error(&self) -> zbus::Result<(String, String)>;

    /// LoadState property
    #[dbus_proxy(property)]
    fn load_state(&self) -> zbus::Result<String>;

    /// Markers property
    #[dbus_proxy(property)]
    fn markers(&self) -> zbus::Result<Vec<String>>;

    /// Names property
    #[dbus_proxy(property)]
    fn names(&self) -> zbus::Result<Vec<String>>;

    /// NeedDaemonReload property
    #[dbus_proxy(property)]
    fn need_daemon_reload(&self) -> zbus::Result<bool>;

    /// OnFailure property
    #[dbus_proxy(property)]
    fn on_failure(&self) -> zbus::Result<Vec<String>>;

    /// OnFailureJobMode property
    #[dbus_proxy(property)]
    fn on_failure_job_mode(&self) -> zbus::Result<String>;

    /// OnFailureOf property
    #[dbus_proxy(property)]
    fn on_failure_of(&self) -> zbus::Result<Vec<String>>;

    /// OnSuccess property
    #[dbus_proxy(property)]
    fn on_success(&self) -> zbus::Result<Vec<String>>;

    /// OnSuccessJobMode property
    #[dbus_proxy(property)]
    fn on_success_job_mode(&self) -> zbus::Result<String>;

    /// OnSuccessOf property
    #[dbus_proxy(property)]
    fn on_success_of(&self) -> zbus::Result<Vec<String>>;

    /// PartOf property
    #[dbus_proxy(property)]
    fn part_of(&self) -> zbus::Result<Vec<String>>;

    /// Perpetual property
    #[dbus_proxy(property)]
    fn perpetual(&self) -> zbus::Result<bool>;

    /// PropagatesReloadTo property
    #[dbus_proxy(property)]
    fn propagates_reload_to(&self) -> zbus::Result<Vec<String>>;

    /// PropagatesStopTo property
    #[dbus_proxy(property)]
    fn propagates_stop_to(&self) -> zbus::Result<Vec<String>>;

    /// RebootArgument property
    #[dbus_proxy(property)]
    fn reboot_argument(&self) -> zbus::Result<String>;

    /// Refs property
    #[dbus_proxy(property)]
    fn refs(&self) -> zbus::Result<Vec<String>>;

    /// RefuseManualStart property
    #[dbus_proxy(property)]
    fn refuse_manual_start(&self) -> zbus::Result<bool>;

    /// RefuseManualStop property
    #[dbus_proxy(property)]
    fn refuse_manual_stop(&self) -> zbus::Result<bool>;

    /// ReloadPropagatedFrom property
    #[dbus_proxy(property)]
    fn reload_propagated_from(&self) -> zbus::Result<Vec<String>>;

    /// RequiredBy property
    #[dbus_proxy(property)]
    fn required_by(&self) -> zbus::Result<Vec<String>>;

    /// Requires property
    #[dbus_proxy(property)]
    fn requires(&self) -> zbus::Result<Vec<String>>;

    /// RequiresMountsFor property
    #[dbus_proxy(property)]
    fn requires_mounts_for(&self) -> zbus::Result<Vec<String>>;

    /// Requisite property
    #[dbus_proxy(property)]
    fn requisite(&self) -> zbus::Result<Vec<String>>;

    /// RequisiteOf property
    #[dbus_proxy(property)]
    fn requisite_of(&self) -> zbus::Result<Vec<String>>;

    /// SliceOf property
    #[dbus_proxy(property)]
    fn slice_of(&self) -> zbus::Result<Vec<String>>;

    /// SourcePath property
    #[dbus_proxy(property)]
    fn source_path(&self) -> zbus::Result<String>;

    /// StartLimitAction property
    #[dbus_proxy(property)]
    fn start_limit_action(&self) -> zbus::Result<String>;

    /// StartLimitBurst property
    #[dbus_proxy(property)]
    fn start_limit_burst(&self) -> zbus::Result<u32>;

    /// StartLimitIntervalUSec property
    #[dbus_proxy(property, name = "StartLimitIntervalUSec")]
    fn start_limit_interval_usec(&self) -> zbus::Result<u64>;

    /// StateChangeTimestamp property
    #[dbus_proxy(property)]
    fn state_change_timestamp(&self) -> zbus::Result<u64>;

    /// StateChangeTimestampMonotonic property
    #[dbus_proxy(property)]
    fn state_change_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// StopPropagatedFrom property
    #[dbus_proxy(property)]
    fn stop_propagated_from(&self) -> zbus::Result<Vec<String>>;

    /// StopWhenUnneeded property
    #[dbus_proxy(property)]
    fn stop_when_unneeded(&self) -> zbus::Result<bool>;

    /// SubState property
    #[dbus_proxy(property)]
    fn sub_state(&self) -> zbus::Result<String>;

    /// SuccessAction property
    #[dbus_proxy(property)]
    fn success_action(&self) -> zbus::Result<String>;

    /// SuccessActionExitStatus property
    #[dbus_proxy(property)]
    fn success_action_exit_status(&self) -> zbus::Result<i32>;

    /// Transient property
    #[dbus_proxy(property)]
    fn transient(&self) -> zbus::Result<bool>;

    /// TriggeredBy property
    #[dbus_proxy(property)]
    fn triggered_by(&self) -> zbus::Result<Vec<String>>;

    /// Triggers property
    #[dbus_proxy(property)]
    fn triggers(&self) -> zbus::Result<Vec<String>>;

    /// UnitFilePreset property
    #[dbus_proxy(property)]
    fn unit_file_preset(&self) -> zbus::Result<String>;

    /// UnitFileState property
    #[dbus_proxy(property)]
    fn unit_file_state(&self) -> zbus::Result<String>;

    /// UpheldBy property
    #[dbus_proxy(property)]
    fn upheld_by(&self) -> zbus::Result<Vec<String>>;

    /// Upholds property
    #[dbus_proxy(property)]
    fn upholds(&self) -> zbus::Result<Vec<String>>;

    /// WantedBy property
    #[dbus_proxy(property)]
    fn wanted_by(&self) -> zbus::Result<Vec<String>>;

    /// Wants property
    #[dbus_proxy(property)]
    fn wants(&self) -> zbus::Result<Vec<String>>;
}
